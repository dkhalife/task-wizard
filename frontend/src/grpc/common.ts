// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export enum FrequencyType {
  FREQUENCY_TYPE_UNSPECIFIED = 0,
  FREQUENCY_TYPE_ONCE = 1,
  FREQUENCY_TYPE_DAILY = 2,
  FREQUENCY_TYPE_WEEKLY = 3,
  FREQUENCY_TYPE_MONTHLY = 4,
  FREQUENCY_TYPE_YEARLY = 5,
  FREQUENCY_TYPE_CUSTOM = 6,
  UNRECOGNIZED = -1,
}

export function frequencyTypeFromJSON(object: any): FrequencyType {
  switch (object) {
    case 0:
    case "FREQUENCY_TYPE_UNSPECIFIED":
      return FrequencyType.FREQUENCY_TYPE_UNSPECIFIED;
    case 1:
    case "FREQUENCY_TYPE_ONCE":
      return FrequencyType.FREQUENCY_TYPE_ONCE;
    case 2:
    case "FREQUENCY_TYPE_DAILY":
      return FrequencyType.FREQUENCY_TYPE_DAILY;
    case 3:
    case "FREQUENCY_TYPE_WEEKLY":
      return FrequencyType.FREQUENCY_TYPE_WEEKLY;
    case 4:
    case "FREQUENCY_TYPE_MONTHLY":
      return FrequencyType.FREQUENCY_TYPE_MONTHLY;
    case 5:
    case "FREQUENCY_TYPE_YEARLY":
      return FrequencyType.FREQUENCY_TYPE_YEARLY;
    case 6:
    case "FREQUENCY_TYPE_CUSTOM":
      return FrequencyType.FREQUENCY_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FrequencyType.UNRECOGNIZED;
  }
}

export function frequencyTypeToJSON(object: FrequencyType): string {
  switch (object) {
    case FrequencyType.FREQUENCY_TYPE_UNSPECIFIED:
      return "FREQUENCY_TYPE_UNSPECIFIED";
    case FrequencyType.FREQUENCY_TYPE_ONCE:
      return "FREQUENCY_TYPE_ONCE";
    case FrequencyType.FREQUENCY_TYPE_DAILY:
      return "FREQUENCY_TYPE_DAILY";
    case FrequencyType.FREQUENCY_TYPE_WEEKLY:
      return "FREQUENCY_TYPE_WEEKLY";
    case FrequencyType.FREQUENCY_TYPE_MONTHLY:
      return "FREQUENCY_TYPE_MONTHLY";
    case FrequencyType.FREQUENCY_TYPE_YEARLY:
      return "FREQUENCY_TYPE_YEARLY";
    case FrequencyType.FREQUENCY_TYPE_CUSTOM:
      return "FREQUENCY_TYPE_CUSTOM";
    case FrequencyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IntervalUnit {
  INTERVAL_UNIT_UNSPECIFIED = 0,
  INTERVAL_UNIT_HOURS = 1,
  INTERVAL_UNIT_DAYS = 2,
  INTERVAL_UNIT_WEEKS = 3,
  INTERVAL_UNIT_MONTHS = 4,
  INTERVAL_UNIT_YEARS = 5,
  UNRECOGNIZED = -1,
}

export function intervalUnitFromJSON(object: any): IntervalUnit {
  switch (object) {
    case 0:
    case "INTERVAL_UNIT_UNSPECIFIED":
      return IntervalUnit.INTERVAL_UNIT_UNSPECIFIED;
    case 1:
    case "INTERVAL_UNIT_HOURS":
      return IntervalUnit.INTERVAL_UNIT_HOURS;
    case 2:
    case "INTERVAL_UNIT_DAYS":
      return IntervalUnit.INTERVAL_UNIT_DAYS;
    case 3:
    case "INTERVAL_UNIT_WEEKS":
      return IntervalUnit.INTERVAL_UNIT_WEEKS;
    case 4:
    case "INTERVAL_UNIT_MONTHS":
      return IntervalUnit.INTERVAL_UNIT_MONTHS;
    case 5:
    case "INTERVAL_UNIT_YEARS":
      return IntervalUnit.INTERVAL_UNIT_YEARS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IntervalUnit.UNRECOGNIZED;
  }
}

export function intervalUnitToJSON(object: IntervalUnit): string {
  switch (object) {
    case IntervalUnit.INTERVAL_UNIT_UNSPECIFIED:
      return "INTERVAL_UNIT_UNSPECIFIED";
    case IntervalUnit.INTERVAL_UNIT_HOURS:
      return "INTERVAL_UNIT_HOURS";
    case IntervalUnit.INTERVAL_UNIT_DAYS:
      return "INTERVAL_UNIT_DAYS";
    case IntervalUnit.INTERVAL_UNIT_WEEKS:
      return "INTERVAL_UNIT_WEEKS";
    case IntervalUnit.INTERVAL_UNIT_MONTHS:
      return "INTERVAL_UNIT_MONTHS";
    case IntervalUnit.INTERVAL_UNIT_YEARS:
      return "INTERVAL_UNIT_YEARS";
    case IntervalUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RepeatOn {
  REPEAT_ON_UNSPECIFIED = 0,
  REPEAT_ON_INTERVAL = 1,
  REPEAT_ON_DAYS_OF_THE_WEEK = 2,
  REPEAT_ON_DAY_OF_THE_MONTHS = 3,
  UNRECOGNIZED = -1,
}

export function repeatOnFromJSON(object: any): RepeatOn {
  switch (object) {
    case 0:
    case "REPEAT_ON_UNSPECIFIED":
      return RepeatOn.REPEAT_ON_UNSPECIFIED;
    case 1:
    case "REPEAT_ON_INTERVAL":
      return RepeatOn.REPEAT_ON_INTERVAL;
    case 2:
    case "REPEAT_ON_DAYS_OF_THE_WEEK":
      return RepeatOn.REPEAT_ON_DAYS_OF_THE_WEEK;
    case 3:
    case "REPEAT_ON_DAY_OF_THE_MONTHS":
      return RepeatOn.REPEAT_ON_DAY_OF_THE_MONTHS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RepeatOn.UNRECOGNIZED;
  }
}

export function repeatOnToJSON(object: RepeatOn): string {
  switch (object) {
    case RepeatOn.REPEAT_ON_UNSPECIFIED:
      return "REPEAT_ON_UNSPECIFIED";
    case RepeatOn.REPEAT_ON_INTERVAL:
      return "REPEAT_ON_INTERVAL";
    case RepeatOn.REPEAT_ON_DAYS_OF_THE_WEEK:
      return "REPEAT_ON_DAYS_OF_THE_WEEK";
    case RepeatOn.REPEAT_ON_DAY_OF_THE_MONTHS:
      return "REPEAT_ON_DAY_OF_THE_MONTHS";
    case RepeatOn.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotificationProviderType {
  NOTIFICATION_PROVIDER_NONE = 0,
  NOTIFICATION_PROVIDER_WEBHOOK = 1,
  NOTIFICATION_PROVIDER_GOTIFY = 2,
  UNRECOGNIZED = -1,
}

export function notificationProviderTypeFromJSON(object: any): NotificationProviderType {
  switch (object) {
    case 0:
    case "NOTIFICATION_PROVIDER_NONE":
      return NotificationProviderType.NOTIFICATION_PROVIDER_NONE;
    case 1:
    case "NOTIFICATION_PROVIDER_WEBHOOK":
      return NotificationProviderType.NOTIFICATION_PROVIDER_WEBHOOK;
    case 2:
    case "NOTIFICATION_PROVIDER_GOTIFY":
      return NotificationProviderType.NOTIFICATION_PROVIDER_GOTIFY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationProviderType.UNRECOGNIZED;
  }
}

export function notificationProviderTypeToJSON(object: NotificationProviderType): string {
  switch (object) {
    case NotificationProviderType.NOTIFICATION_PROVIDER_NONE:
      return "NOTIFICATION_PROVIDER_NONE";
    case NotificationProviderType.NOTIFICATION_PROVIDER_WEBHOOK:
      return "NOTIFICATION_PROVIDER_WEBHOOK";
    case NotificationProviderType.NOTIFICATION_PROVIDER_GOTIFY:
      return "NOTIFICATION_PROVIDER_GOTIFY";
    case NotificationProviderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotificationType {
  NOTIFICATION_TYPE_UNSPECIFIED = 0,
  NOTIFICATION_TYPE_DUE_DATE = 1,
  NOTIFICATION_TYPE_PRE_DUE = 2,
  NOTIFICATION_TYPE_OVERDUE = 3,
  UNRECOGNIZED = -1,
}

export function notificationTypeFromJSON(object: any): NotificationType {
  switch (object) {
    case 0:
    case "NOTIFICATION_TYPE_UNSPECIFIED":
      return NotificationType.NOTIFICATION_TYPE_UNSPECIFIED;
    case 1:
    case "NOTIFICATION_TYPE_DUE_DATE":
      return NotificationType.NOTIFICATION_TYPE_DUE_DATE;
    case 2:
    case "NOTIFICATION_TYPE_PRE_DUE":
      return NotificationType.NOTIFICATION_TYPE_PRE_DUE;
    case 3:
    case "NOTIFICATION_TYPE_OVERDUE":
      return NotificationType.NOTIFICATION_TYPE_OVERDUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationType.UNRECOGNIZED;
  }
}

export function notificationTypeToJSON(object: NotificationType): string {
  switch (object) {
    case NotificationType.NOTIFICATION_TYPE_UNSPECIFIED:
      return "NOTIFICATION_TYPE_UNSPECIFIED";
    case NotificationType.NOTIFICATION_TYPE_DUE_DATE:
      return "NOTIFICATION_TYPE_DUE_DATE";
    case NotificationType.NOTIFICATION_TYPE_PRE_DUE:
      return "NOTIFICATION_TYPE_PRE_DUE";
    case NotificationType.NOTIFICATION_TYPE_OVERDUE:
      return "NOTIFICATION_TYPE_OVERDUE";
    case NotificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ApiTokenScope {
  API_TOKEN_SCOPE_UNSPECIFIED = 0,
  API_TOKEN_SCOPE_TASK_READ = 1,
  API_TOKEN_SCOPE_TASK_WRITE = 2,
  API_TOKEN_SCOPE_LABEL_READ = 3,
  API_TOKEN_SCOPE_LABEL_WRITE = 4,
  API_TOKEN_SCOPE_USER_READ = 5,
  API_TOKEN_SCOPE_USER_WRITE = 6,
  API_TOKEN_SCOPE_TOKEN_WRITE = 7,
  API_TOKEN_SCOPE_DAV_READ = 8,
  API_TOKEN_SCOPE_DAV_WRITE = 9,
  UNRECOGNIZED = -1,
}

export function apiTokenScopeFromJSON(object: any): ApiTokenScope {
  switch (object) {
    case 0:
    case "API_TOKEN_SCOPE_UNSPECIFIED":
      return ApiTokenScope.API_TOKEN_SCOPE_UNSPECIFIED;
    case 1:
    case "API_TOKEN_SCOPE_TASK_READ":
      return ApiTokenScope.API_TOKEN_SCOPE_TASK_READ;
    case 2:
    case "API_TOKEN_SCOPE_TASK_WRITE":
      return ApiTokenScope.API_TOKEN_SCOPE_TASK_WRITE;
    case 3:
    case "API_TOKEN_SCOPE_LABEL_READ":
      return ApiTokenScope.API_TOKEN_SCOPE_LABEL_READ;
    case 4:
    case "API_TOKEN_SCOPE_LABEL_WRITE":
      return ApiTokenScope.API_TOKEN_SCOPE_LABEL_WRITE;
    case 5:
    case "API_TOKEN_SCOPE_USER_READ":
      return ApiTokenScope.API_TOKEN_SCOPE_USER_READ;
    case 6:
    case "API_TOKEN_SCOPE_USER_WRITE":
      return ApiTokenScope.API_TOKEN_SCOPE_USER_WRITE;
    case 7:
    case "API_TOKEN_SCOPE_TOKEN_WRITE":
      return ApiTokenScope.API_TOKEN_SCOPE_TOKEN_WRITE;
    case 8:
    case "API_TOKEN_SCOPE_DAV_READ":
      return ApiTokenScope.API_TOKEN_SCOPE_DAV_READ;
    case 9:
    case "API_TOKEN_SCOPE_DAV_WRITE":
      return ApiTokenScope.API_TOKEN_SCOPE_DAV_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApiTokenScope.UNRECOGNIZED;
  }
}

export function apiTokenScopeToJSON(object: ApiTokenScope): string {
  switch (object) {
    case ApiTokenScope.API_TOKEN_SCOPE_UNSPECIFIED:
      return "API_TOKEN_SCOPE_UNSPECIFIED";
    case ApiTokenScope.API_TOKEN_SCOPE_TASK_READ:
      return "API_TOKEN_SCOPE_TASK_READ";
    case ApiTokenScope.API_TOKEN_SCOPE_TASK_WRITE:
      return "API_TOKEN_SCOPE_TASK_WRITE";
    case ApiTokenScope.API_TOKEN_SCOPE_LABEL_READ:
      return "API_TOKEN_SCOPE_LABEL_READ";
    case ApiTokenScope.API_TOKEN_SCOPE_LABEL_WRITE:
      return "API_TOKEN_SCOPE_LABEL_WRITE";
    case ApiTokenScope.API_TOKEN_SCOPE_USER_READ:
      return "API_TOKEN_SCOPE_USER_READ";
    case ApiTokenScope.API_TOKEN_SCOPE_USER_WRITE:
      return "API_TOKEN_SCOPE_USER_WRITE";
    case ApiTokenScope.API_TOKEN_SCOPE_TOKEN_WRITE:
      return "API_TOKEN_SCOPE_TOKEN_WRITE";
    case ApiTokenScope.API_TOKEN_SCOPE_DAV_READ:
      return "API_TOKEN_SCOPE_DAV_READ";
    case ApiTokenScope.API_TOKEN_SCOPE_DAV_WRITE:
      return "API_TOKEN_SCOPE_DAV_WRITE";
    case ApiTokenScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Frequency {
  type: FrequencyType;
  on: RepeatOn;
  every: number;
  unit: IntervalUnit;
  days: number[];
  months: number[];
}

export interface NotificationTriggerOptions {
  enabled: boolean;
  dueDate: boolean;
  preDue: boolean;
  overdue: boolean;
}

export interface NotificationProvider {
  provider: NotificationProviderType;
  url: string;
  method: string;
  token: string;
}

export interface Empty {
}

function createBaseFrequency(): Frequency {
  return { type: 0, on: 0, every: 0, unit: 0, days: [], months: [] };
}

export const Frequency: MessageFns<Frequency> = {
  encode(message: Frequency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.on !== 0) {
      writer.uint32(16).int32(message.on);
    }
    if (message.every !== 0) {
      writer.uint32(24).int32(message.every);
    }
    if (message.unit !== 0) {
      writer.uint32(32).int32(message.unit);
    }
    writer.uint32(42).fork();
    for (const v of message.days) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.months) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frequency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrequency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.on = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.every = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.days.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.days.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.months.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.months.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frequency {
    return {
      type: isSet(object.type) ? frequencyTypeFromJSON(object.type) : 0,
      on: isSet(object.on) ? repeatOnFromJSON(object.on) : 0,
      every: isSet(object.every) ? globalThis.Number(object.every) : 0,
      unit: isSet(object.unit) ? intervalUnitFromJSON(object.unit) : 0,
      days: globalThis.Array.isArray(object?.days) ? object.days.map((e: any) => globalThis.Number(e)) : [],
      months: globalThis.Array.isArray(object?.months) ? object.months.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Frequency): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = frequencyTypeToJSON(message.type);
    }
    if (message.on !== 0) {
      obj.on = repeatOnToJSON(message.on);
    }
    if (message.every !== 0) {
      obj.every = Math.round(message.every);
    }
    if (message.unit !== 0) {
      obj.unit = intervalUnitToJSON(message.unit);
    }
    if (message.days?.length) {
      obj.days = message.days.map((e) => Math.round(e));
    }
    if (message.months?.length) {
      obj.months = message.months.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Frequency>): Frequency {
    return Frequency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Frequency>): Frequency {
    const message = createBaseFrequency();
    message.type = object.type ?? 0;
    message.on = object.on ?? 0;
    message.every = object.every ?? 0;
    message.unit = object.unit ?? 0;
    message.days = object.days?.map((e) => e) || [];
    message.months = object.months?.map((e) => e) || [];
    return message;
  },
};

function createBaseNotificationTriggerOptions(): NotificationTriggerOptions {
  return { enabled: false, dueDate: false, preDue: false, overdue: false };
}

export const NotificationTriggerOptions: MessageFns<NotificationTriggerOptions> = {
  encode(message: NotificationTriggerOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.dueDate !== false) {
      writer.uint32(16).bool(message.dueDate);
    }
    if (message.preDue !== false) {
      writer.uint32(24).bool(message.preDue);
    }
    if (message.overdue !== false) {
      writer.uint32(32).bool(message.overdue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationTriggerOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationTriggerOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dueDate = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preDue = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.overdue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationTriggerOptions {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      dueDate: isSet(object.dueDate) ? globalThis.Boolean(object.dueDate) : false,
      preDue: isSet(object.preDue) ? globalThis.Boolean(object.preDue) : false,
      overdue: isSet(object.overdue) ? globalThis.Boolean(object.overdue) : false,
    };
  },

  toJSON(message: NotificationTriggerOptions): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.dueDate !== false) {
      obj.dueDate = message.dueDate;
    }
    if (message.preDue !== false) {
      obj.preDue = message.preDue;
    }
    if (message.overdue !== false) {
      obj.overdue = message.overdue;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationTriggerOptions>): NotificationTriggerOptions {
    return NotificationTriggerOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationTriggerOptions>): NotificationTriggerOptions {
    const message = createBaseNotificationTriggerOptions();
    message.enabled = object.enabled ?? false;
    message.dueDate = object.dueDate ?? false;
    message.preDue = object.preDue ?? false;
    message.overdue = object.overdue ?? false;
    return message;
  },
};

function createBaseNotificationProvider(): NotificationProvider {
  return { provider: 0, url: "", method: "", token: "" };
}

export const NotificationProvider: MessageFns<NotificationProvider> = {
  encode(message: NotificationProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.token !== "") {
      writer.uint32(34).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationProvider {
    return {
      provider: isSet(object.provider) ? notificationProviderTypeFromJSON(object.provider) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: NotificationProvider): unknown {
    const obj: any = {};
    if (message.provider !== 0) {
      obj.provider = notificationProviderTypeToJSON(message.provider);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationProvider>): NotificationProvider {
    return NotificationProvider.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationProvider>): NotificationProvider {
    const message = createBaseNotificationProvider();
    message.provider = object.provider ?? 0;
    message.url = object.url ?? "";
    message.method = object.method ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
